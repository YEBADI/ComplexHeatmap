
#####################################
# class and methods to map values to colors
#

# == title
# Class to map values to colors
#
# == details
# The `ColorMapping-class` handles color mapping with both discrete values and continuous values.
# Discrete values are mapped by setting a vector of colors and continuous values are mapped by setting
# a color mapping function.
#
# == methods
# The `ColorMapping-class` provides following methods:
#
# - `ColorMapping`: contructor methods.
# - `map_to_colors,ColorMapping-method`: mapping values to colors.
# - `color_mapping_legend,ColorMapping-method`: draw legend or get legend as a `grid::grob` object.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
ColorMapping = setClass("ColorMapping",
	slots = list(
		colors  = "character", # a list of colors
		levels  = "ANY", # levels which colors correspond to
		col_fun = "function", # function to map values to colors
		type    = "character",  # continuous or discrete
		name    = "character",  # used to map to the dataset and taken as the title of the legend
		na_col  = "character"	
	)
)

# == title
# Constructor methods for ColorMapping class
#
# == param
# -name name for this color mapping. The name is automatically generated if it is not specified.
# -colors discrete colors.
# -levels levels that correspond to ``colors``. If ``colors`` is name indexed, 
#         ``levels`` can be ignored.
# -col_fun color mapping function that maps continuous values to colors.
# -breaks breaks for the continuous color mapping. If ``col_fun`` is
#         generated by `circlize::colorRamp2`, ``breaks`` can be ignored.
# -na_col colors for ``NA`` values.
#
# == detail
# ``colors`` and ``levels`` are used for discrete color mapping, ``col_fun`` and 
# ``breaks`` are used for continuous color mapping.
#
# == value
# A `ColorMapping-class` object.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
ColorMapping = function(name, colors = NULL, levels = NULL, 
	col_fun = NULL, breaks = NULL, na_col = "#FFFFFF") {

	.Object = new("ColorMapping")

	if(missing(name)) {
		increase_color_mapping_index()
		name = paste0("color_mapping_", get_color_mapping_index())
	}
	if(!is.null(colors)) {
		if(is.null(levels)) {
			if(is.null(names(colors))) {
				stop("either provide `levels` or provide named `colors`.\n")
			}
			levels = names(colors)
		}
		if(length(colors) != length(levels)) {
			stop("length of colors and length of levels should be the same.\n")
		}
		colors = t(col2rgb(colors, alpha = TRUE))
		colors = rgb(colors[, 1:3, drop = FALSE], alpha = colors[, 4], maxColorValue = 255)
		.Object@colors = colors
		if(is.numeric(levels)) {
			.Object@levels = as.character(levels)
			#attr(.Object@levels, "numeric") = TRUE
		} else {
			.Object@levels = levels
		}
		names(.Object@colors) = levels
		.Object@type = "discrete"
	} else if(!is.null(col_fun)) {
		if(is.null(breaks)) {
			breaks = attr(col_fun, "breaks")
			if(is.null(breaks)) {
				stop("You should provide breaks.\n")
			}
		}
		
		le1 = grid.pretty(range(breaks))
		le2 = pretty(breaks, n = 3)
		if(abs(length(le1) - 5) < abs(length(le2) - 5)) {
			le = le1
		} else {
			le = le2
		}
		
		.Object@colors = col_fun(le)
		.Object@levels = le
		.Object@col_fun = col_fun
		.Object@type = "continuous"
	} else {
		stop("initialization failed. Either specify `colors` + `levels` or `col_fun` + `breaks`\n")
	}

	.Object@name = name
	na_col = t(col2rgb(na_col, alpha = TRUE))
	na_col = rgb(na_col[, 1:3, drop = FALSE], alpha = na_col[, 4], maxColorValue = 255)
	.Object@na_col = na_col[1]

	return(.Object)
}

# == title
# Print ColorMapping object
#
# == param
# -object a `ColorMapping-class` object.
#
# == value
# This function returns no value.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "show",
	signature = "ColorMapping",
	definition = function(object) {
	if(object@type == "discrete") {
		cat("Discrete color mapping:\n")
		cat("name:", object@name, "\n")
		cat("levels:\n")
		print(object@levels)
		cat("\n")
		cat("colors:\n")
		col = object@colors; names(col) = NULL
		print(col)
		cat("\n")
	} else if(object@type == "continuous") {
		cat("Continuous color mapping:\n")
		cat("name:", object@name, "\n")
		cat("default breaks:\n")
		print(object@levels)
		cat("\n")
		cat("colors:\n")
		col = object@colors; names(col) = NULL
		print(col)
		cat("\n")
	}
})

# == title
# Map values to colors
#
# == param
# -object a `ColorMapping-class` object.
# -x input values.
#
# == details
# It maps a vector of values to a vector of colors.
#
# == value
# A vector of colors.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "map_to_colors",
	signature = "ColorMapping",
	definition = function(object, x) {
	
	if(is.factor(x)) x = as.vector(x)
	original_attr = attributes(x)
	x2 = vector(length = length(x))

	if(object@type == "discrete") {
		lna = is.na(x)

		if(is.numeric(x)) x = as.character(x)
		if(any(! x[!lna] %in% object@levels)) {
			msg = paste0(object@name, ": cannot map some of the levels:\n", paste(setdiff(x[!lna], object@levels), sep = ", ", collapse = ", "))
			stop(msg)
		}
		
		x2[lna] = object@na_col
		x2[!lna] = object@colors[ x[!lna] ]
	} else {
		lna = is.na(x)
		x2[lna] = object@na_col
		x2[!lna] = object@col_fun(x[!lna])
	}

	# keep original attributes, such as dimension
	attributes(x2) = original_attr
	return(x2)
})


# == title
# Draw legend based on color mapping
#
# == param
# -object a `ColorMapping-class` object.
# -... pass to `grid::viewport`.
# -plot whether to plot or just return the size of the legend viewport.
# -title title of the legend, by default it is the name of the legend
# -title_gp graphical parameters for legend title
# -color_bar if the mapping is continuous, whether show the legend as discrete color bar or continuous color bar
# -grid_height height of each legend grid.
# -grid_width width of each legend grid.
# -grid_border color for legend grid borders.
# -at break values of the legend
# -labels labels corresponding to break values
# -labels_gp graphcial parameters for legend labels
# -param will be parsed if the parameters are specified as a list
#
# == details
# A viewport is created which contains a legend title, legend grids and corresponding labels.
#
# This function will be improved in the future to support more types of legends.
#
# == value
# A `grid::grob` object which contains the legend
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "color_mapping_legend",
	signature = "ColorMapping",
	definition = function(object, ..., 
	plot = TRUE, 
	title = object@name,
	title_gp = gpar(fontsize = 10, fontface = "bold"),
	color_bar = c("discrete", "continuous"),
	grid_height = unit(4, "mm"),
	grid_width = unit(4, "mm"),
	grid_border = "white",
	at = object@levels,
	labels = at,
	labels_gp = gpar(fontsize = 10),
	param = NULL) {

	e = environment()
	if(!is.null(param)) {
		for(nm in names(param)) {
			assign(nm, param[[nm]], envir = e)
		}
	}

	title_gp = check_gp(title_gp)
	labels_gp = check_gp(labels_gp)

	color_bar = match.arg(color_bar)

	if(object@type == "discrete" && color_bar == "continuous") {
		stop("'color_bar' can only be set to 'continuous' only if the color mapping is continuous")
	}

	labels_padding_left = unit(1, "mm") # padding to the legend labels

	# add title
	title_grob = textGrob(title, just = c("left", "top"), gp = title_gp)
	title_height = grobHeight(title_grob) + unit(1.5, "mm")
	title_width = grobWidth(title_grob)

	# get labels
	if(length(at) != length(labels)) {
		stop("Length of 'at' should be same as length of 'labels'.")
	}
	# if it is character color mapping, remove items in `at` which are not in the available optinos
	if(color_bar == "discrete" && is.character(at)) {
		l = which(at %in% object@levels)
		at = at[l]
		labels = labels[l]
	}
	n_labels = length(labels)
	labels_max_width = max(do.call("unit.c", lapply(labels, function(x) {
			grobWidth(textGrob(x, gp = labels_gp))
		})))

	labels_max_width = max(unit.c(labels_max_width + labels_padding_left + grid_width, title_width)) - grid_width - labels_padding_left
	
	
	if(color_bar == "discrete") {
		gf = frameGrob(layout = grid.layout(nrow = 2, ncol = 2, widths = unit.c(grid_width, labels_padding_left + labels_max_width),
			                                                heights = unit.c(title_height, n_labels*(grid_height))))
		# legend title
		gf = packGrob(gf, row = 1, col = 1:2, grob = textGrob(title, x = 0, y = 1, default.units = "npc", just = c("left", "top"), gp = title_gp))
		
		# legend grid
		x = unit(rep(0, n_labels), "npc")
		y = (0:(n_labels-1))*(grid_height)
		y = unit(1, "npc") - y
		if(object@type == "discrete") {
			gf = packGrob(gf, row = 2, col = 2, grob = textGrob(labels, x + labels_padding_left, y - grid_height*0.5, 
		 		just = c("left", "center"), gp = labels_gp), width = labels_padding_left + labels_max_width, force.width = TRUE)
			gf = packGrob(gf, row = 2, col = 1, grob = rectGrob(x, y, width = grid_width, height = grid_height, just = c("left", "top"),
					gp = gpar(col = grid_border, fill = map_to_colors(object, at))))
		} else {
			gf = packGrob(gf, row = 2, col = 2, grob = textGrob(labels, x + labels_padding_left, rev(y) - grid_height*0.5, 
		 		just = c("left", "center"), gp = labels_gp), width = labels_padding_left + labels_max_width, force.width = TRUE)
			gf = packGrob(gf, row = 2, col = 1, grob = rectGrob(x, rev(y), width = grid_width, height = rev(grid_height), just = c("left", "top"),
					gp = gpar(col = grid_border, fill = map_to_colors(object, at))))
		}
	} else {
		labels_height = grobHeight(textGrob("foo", gp = labels_gp))
		gf = frameGrob(layout = grid.layout(nrow = 2, ncol = 2, widths = unit.c(grid_width, labels_padding_left + labels_max_width),
			                                                heights = unit.c(title_height, (2*n_labels-1)*labels_height)))
		# legend title
		gf = packGrob(gf, row = 1, col = 1:2, grob = textGrob(title, x = 0, y = 1, default.units = "npc", just = c("left", "top"), gp = title_gp))
		
		# legend grid
		x = unit(rep(0, n_labels), "npc")
		y = seq(0, 1, length = n_labels) * (unit(1, "npc") - labels_height) + labels_height*0.5
		y = unit(1, "npc") - y
		gf = packGrob(gf, row = 2, col = 2, grob = textGrob(labels, x + labels_padding_left, rev(y), 
	 		just = c("left", "center"), gp = labels_gp), width = labels_padding_left + labels_max_width, force.width = TRUE, height = (2*n_labels-1)*labels_height, force.height = TRUE)

		at2 = unlist(lapply(seq_len(n_labels - 1), function(i) {
			x = seq(at[i], at[i+1], length = 16)
			x = x[-length(x)]
		}))
		at2 = c(at2, at[length(at)])
		colors = map_to_colors(object, at2)
		x2 = unit(rep(0, length(colors)), "npc")
		y2 = seq(0, 1, length = length(colors)+1)
		y2 = y2[-length(y2)] * unit(1, "npc")
		gf = packGrob(gf, row = 2, col = 1, grob = rectGrob(x2, rev(y2), width = grid_width, height = (unit(1, "npc"))*(1/length(colors)), just = c("left", "top"),
				gp = gpar(col = rev(colors), fill = rev(colors))), height = (2*n_labels-1)*labels_height, force.height = TRUE)
		gf = packGrob(gf, row = 2, col = 1, grob = segmentsGrob(unit(0, "npc"), y, unit(0.8, "mm"), y, gp = gpar(col = "white")), 
			    height = (2*n_labels-1)*labels_height, force.height = TRUE)
		gf = packGrob(gf, row = 2, col = 1, grob = segmentsGrob(unit(1, "npc"), y, unit(1, "npc") - unit(0.8, "mm"), y, gp = gpar(col = "white")), 
			    height = (2*n_labels-1)*labels_height, force.height = TRUE)
	}
	

	if(plot) {
		pushViewport(viewport(..., width = grobWidth(gf), height = grobHeight(gf), name = paste0("legend_", object@name)))
		grid.draw(gf)
		upViewport()
	}

	#size = unit.c(vp_width, vp_height)
	return(invisible(gf))
})
