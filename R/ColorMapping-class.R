
#####################################
# class and methods to map values to colors
#

# == title
# Class to map values to colors
#
# == details
# The `ColorMapping-class` handles color mapping with both discrete values and continuous values.
# Discrete values are mapped by setting a vector of colors and continuous values are mapped by setting
# a color mapping function.
#
# == methods
# The `ColorMapping-class` provides following methods:
#
# - `ColorMapping`: contructor methods.
# - `map_to_colors,ColorMapping-method`: mapping values to colors.
# - `color_mapping_legend,ColorMapping-method`: draw legend or get the size of the legend.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
ColorMapping = setClass("ColorMapping",
	slots = list(
		colors  = "character", # a list of colors
		levels  = "character", # levels which colors correspond to
		col_fun = "function", # function to map values to colors
		type    = "character",  # continuous or discrete
		name    = "character"  # used to map to the dataset and taken as the title of the legend
	)
)

# == title
# Constructor methods for ColorMapping class
#
# == param
# -name name for this color mapping. It is used for drawing the title of the legend.
# -colors discrete colors.
# -levels levels that correspond to ``colors``. If ``colors`` is name indexed, 
#         ``levels`` can be ignored.
# -col_fun color mapping function that maps continuous values to colors.
# -breaks breaks for the continuous color mapping. If ``col_fun`` is
#         generated by `circlize::colorRamp2`, ``breaks`` can be ignored.
#
# == detail
# ``colors`` and ``levels`` are used for discrete color mapping, ``col_fun`` and 
# ``breaks`` are used for continuous color mapping.
#
# == value
# A `ColorMapping-class` object.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
ColorMapping = function(name, colors = NULL, levels = NULL, 
	col_fun = NULL, breaks = NULL) {

	.Object = new("ColorMapping")

	if(is.null(name)) {
		stop("You should provide name.")
	}
	if(!is.null(colors)) {
		if(is.null(levels)) {
			if(is.null(names(colors))) {
				stop("either provide `levels` or provide named `colors`.\n")
			}
			levels = names(colors)
		}
		if(length(colors) != length(levels)) {
			stop("length of colors and length of levels should be the same.\n")
		}
		.Object@colors = colors
		if(is.numeric(levels)) {
			.Object@levels = as.character(levels)
			#attr(.Object@levels, "numeric") = TRUE
		} else {
			.Object@levels = levels
		}
		names(.Object@colors) = levels
		.Object@type = "discrete"
	} else if(!is.null(col_fun)) {
		if(is.null(breaks)) {
			breaks = attr(col_fun, "breaks")
			if(is.null(breaks)) {
				stop("You should provide breaks.\n")
			}
		}
		le1 = grid.pretty(range(breaks))
		le2 = pretty(breaks, n = 3)
		if(abs(length(le1) - 5) < abs(length(le2) - 5)) {
			le = le1
		} else {
			le = le2
		}
		.Object@colors = col_fun(le)
		.Object@levels = as.character(le)
		.Object@col_fun = col_fun
		.Object@type = "continuous"
	} else {
		stop("initialization failed. Either specify `colors` + `levels` or `col_fun` + `breaks`\n")
	}

	.Object@name = name

	return(.Object)
}

# == title
# Print ColorMapping object
#
# == param
# -object a `ColorMapping-class` object.
#
# == value
# This function returns no value.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "show",
	signature = "ColorMapping",
	definition = function(object) {
	if(object@type == "discrete") {
		cat("Discrete color mapping:\n")
		cat("name:", object@name, "\n")
		cat("levels:\n")
		print(object@levels)
		cat("\n")
		cat("colors:\n")
		col = object@colors; names(col) = NULL
		print(col)
		cat("\n")
	} else if(object@type == "continuous") {
		cat("Continuous color mapping:\n")
		cat("name:", object@name, "\n")
		cat("breaks:\n")
		print(object@levels)
		cat("\n")
		cat("colors:\n")
		col = object@colors; names(col) = NULL
		print(col)
		cat("\n")
	}
})

# == title
# Map values to colors
#
# == param
# -object a `ColorMapping-class` object.
# -x input values.
#
# == details
# It maps a vector of values to a vector of colors.
#
# == value
# A vector of colors.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "map_to_colors",
	signature = "ColorMapping",
	definition = function(object, x) {
	
	if(is.factor(x)) x = as.vector(x)
	original_attr = attributes(x)
	if(object@type == "discrete") {
		if(is.numeric(x)) x = as.character(x)
		if(any(! x %in% object@levels)) {
			msg = paste0("Cannot map some of the levels:\n", paste(setdiff(x, object@levels), sep = ", ", collapse = ", "))
			stop(msg)
		}
		x = object@colors[x]
	} else {
		x = object@col_fun(x)
	}

	# keep original attributes, such as dimension
	attributes(x) = original_attr
	return(x)
})


# == title
# Draw legend based on color mapping
#
# == param
# -object a `ColorMapping-class` object.
# -... pass to `grid::viewport`.
# -plot whether to plot or just return the size of the legend viewport.
# -legend_grid_height height of each legend grid.
# -legend_grid_width width of each legend grid.
# -legend_title_gp graphic parameter for legend title.
# -legend_label_gp graphic parameter for legend label.
#
# == details
# A viewport is created which contains a legend title, legend grids and corresponding labels.
#
# == value
# A `grid::unit` object which corresponds to the width and height of the legend viewport.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "color_mapping_legend",
	signature = "ColorMapping",
	definition = function(object, ..., plot = TRUE, legend_grid_height = unit(3, "mm"),
	legend_grid_width = unit(3, "mm"), 
	legend_title_gp = gpar(fontsize = 10, fontface = "bold"),
	legend_label_gp = gpar(fontsize = 10)) {

	legend_title_gp = check_gp(legend_title_gp)
	legend_label_gp = check_gp(legend_label_gp)

	# add title
	legend_title_grob = textGrob(object@name, just = c("left", "top"), gp = legend_title_gp)
	legend_title_height = grobHeight(legend_title_grob)
	legend_title_width = grobWidth(legend_title_grob)

	nlevel = length(object@levels)
	x = unit(rep(0, nlevel), "npc")
	y = 1.5*legend_title_height + (0:(nlevel-1))*(legend_grid_height + unit(1, "mm"))
	y = unit(1, "npc") - y
	legend_label_max_width = max(do.call("unit.c", lapply(object@levels, function(x) {
			grobWidth(textGrob(x, gp = legend_label_gp))
		})))
	vp_width = max(unit.c(legend_title_width, 
				   legend_grid_width + unit(1, "mm") + legend_label_max_width ))
	vp_height = legend_title_height*1.5 + nlevel*(legend_grid_height + unit(1, "mm"))

	if(plot) {
		pushViewport(viewport(..., width = vp_width, height = vp_height, name = paste0("legend_", object@name)))
		grid.text(object@name, unit(0, "npc"), unit(1, "npc"), just = c("left", "top"), 
			gp = legend_title_gp)
		grid.rect(x, rev(y), width = legend_grid_width, height = rev(legend_grid_height), just = c("left", "top"),
			gp = gpar(col = NA, fill = object@colors))
		grid.text(rev(object@levels), x + legend_grid_width + unit(1, "mm"), y - legend_grid_height*0.5, 
			just = c("left", "center"), gp = legend_label_gp)
		upViewport()
	}

	size = unit.c(vp_width, vp_height)
	return(invisible(size))
})
